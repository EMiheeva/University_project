#https://e-maxx.ru/algo/kuhn_matching
#в левой доле n = 6 пронумеруй вершины от 0 до 5
#в правой доле k = 10 пронумеруй вершины от 0 до 10
# 1 -> 3, но 3 под номером 2 во второй доле (k=9)
# 1 -> 13, но 13 под номером 4 во второй доле (k=9)
#Вершина 1 под номером 0 из левой доли (n=6) соединена по условию карточки с вершиной 3 под номером 2 в правой доле (k=10).
#Вершина 1 под номером 0 из левой доли (n=6) соединена по условию карточки с вершиной 13 под номером 4 в правой доле (k=10).
#Вершина 1 под номером 0 из левой доли (n=6) соединена по условию карточки с вершиной 12 под номером 5 в правой доле (k=10).
#Вершина 1 под номером 0 из левой доли (n=6) соединена по условию карточки с вершиной 10 под номером 7 в правой доле (k=10).
#получаем первый список для вершины 0(которая 1) [2, 4, 5, 7]

n = 6
k = 9
graph = [[2, 4, 5, 7], 
    [0, 6, 8, 3, 7, 1, 2, 5], 
    [3, 8, 7, 1, 6, 4], 
    [8, 7], 
    [1, 2, 4, 5], 
    [3, 6, 5, 2, 7, 4]]
mt = [-1] * k #содержит в себе информацию о текущем паросочетании. 
            #Для удобства программирования, информация эта содержится только для вершин второй доли: 
            #mt[i] — это номер вершины первой доли, связанной ребром с вершиной i второй доли 
            #(или -1, если никакого ребра паросочетания из i не выходит).
used = [False] * n #Второй массив — used — обычный массив "посещённостей" вершин в обходе в глубину 
                   #(он нужен, просто чтобы обход в глубину не заходил в одну вершину дважды).
mas1 = [1, 2, 14, 5, 7, 8]
mas2 = [6, 15, 3, 4, 13, 12, 11, 10, 9] #mas1 и mas2 это как бы строчки, чтобы правильно обозначить вершины ребер и не запутаться в нумерации. 
                                        #(можно убедиться, что если убрать mas1 и mas2 он будет выводить одни и те же ребра, но их нумерация будет такой, 
                                        #какая она в правой и левой доли - от 0 до 5 и от 0 до 9)

def dfs_try_kuhn(v):
    if used[v]:
        return False
    used[v] = True
    for i in range(len(graph[v])):
        to = graph[v][i]
        if mt[to] == -1 or dfs_try_kuhn(mt[to]):
            mt[to] = v
            return True #Она возвращает true, если ей удалось найти увеличивающую цепь из вершины v, 
                        #при этом считается, что эта функция уже произвела чередование паросочетания вдоль найденной цепи.
    return False

for v in range(n):
    used = [False] * n
    dfs_try_kuhn(v)

count = 0
print("Ребра в максимальном паросочетании: ")
for i in range(k):
    if mt[i] != -1:
        print(mas1[mt[i]], mas2[i])
        count += 1
print(f"Максимальное паросочетание равно: {count}")
