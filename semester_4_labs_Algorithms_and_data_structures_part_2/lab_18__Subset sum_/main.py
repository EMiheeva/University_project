#def print_subset(subset):
    #for i in subset:
        #print(i, end=" ")
    #print()
"""
53
15 22 14 26 32 9 16 8
"""

k = int(input("Введите искомую сумму: "))
a = []
print(f"Введите множество: ")
a = input().split(" ")
a = list(map(lambda x: int(x), a))
print("Подмножества: ")
for mask in range(1 << len(a)): # перебираем все подмножества массива с помощью битовых масок
    sum = 0
    subset = []
    for i in range(len(a)): # для каждого подмножества считаем его сумму и запоминаем числа, которые входят
        if mask & (1 << i): # проверяем что это равно 1 - истине побитовая операция из помощника№2
            """
            Происходит с помощью логического «И». 
            Чтобы узнать, какой будет первая слева цифра в нашем числе, нужна маска 1000. 
            При побитовой операции «1001 И 1000» результатом будет 1000 — это показывает, что нужный бит равен 1. 
            А при операции «0001 И 1000» получится 0000 — это показывает, что бит равен 0.
            В нашем случае, мы такие не учитываем.

            если применить ее к числам mask и x, то мы получим значение большее нуля только при условии,
            что в mask на i-ом месте стоит единичный бит, а это означает, что подмножество можно выбрать.
            
            Помощник №1: https://sch9.ru/files/lectures/ict/bitmasks.pdf
            Помощник №2: https://blog.skillfactory.ru/glossary/bitovaya-maska/
            """
            sum += a[i]
            subset.append(a[i])
    if sum == k:
        #print_subset(subset) # если сумма равна k, то мы выводим это подмножество на консоль
        print(subset)
